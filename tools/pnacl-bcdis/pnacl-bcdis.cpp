//===-- pnacl-bcdis.cpp - Disassemble pnacl bitcode -----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

/// TODO(kschimpf): Add disassembling abbreviations.

#include "llvm/Bitcode/NaCl/NaClBitcodeHeader.h"
#include "llvm/Bitcode/NaCl/NaClBitcodeParser.h"
#include "llvm/Bitcode/NaCl/NaClBitCodes.h"
#include "llvm/Bitcode/NaCl/NaClObjDumpStream.h"
#include "llvm/Bitcode/NaCl/NaClReaderWriter.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Value.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Signals.h"
#include "llvm/Support/ToolOutputFile.h"

namespace llvm {
namespace naclbitc {

// Special record codes used to model codes for predefined records.
// They are very large so that they do not conflict with existing
// record codes for user-defined blocks.
enum SpecialBlockCodes {
  BLK_CODE_ENTER = 65535,
  BLK_CODE_EXIT  = 65534,
  BLK_CODE_DEFINE_ABBREV = 65533,
  BLK_CODE_HEADER = 65532
};

}
}

namespace {

using namespace llvm;

// The input file to read.
static cl::opt<std::string>
  InputFilename(cl::Positional, cl::desc("<input bitcode>"), cl::init("-"));

// The output file to generate.
static cl::opt<std::string>
OutputFilename("o", cl::desc("Specify output filename"),
               cl::value_desc("filename"), cl::init("-"));

static cl::opt<bool>
NoRecords("no-records",
          cl::desc("Don't include records"),
          cl::init(false));

static cl::opt<bool>
NoAssembly("no-assembly",
           cl::desc("Don't include assembly"),
           cl::init(false));

/// Takes the given (signed rotated) unsigned integer, and returns a
/// corresponding signed integer value.
static int64_t GetSignRotatedInt(uint64_t Value, Type* ValueType) {
  // Add sign if applicable (note: booleans can't have a sign).
  bool AddSign =
      (Value & 0x1)
      && !(ValueType->isIntegerTy()
           && ValueType->getIntegerBitWidth() == 1);
  int64_t SignedValue = (Value >> 1);
  if (AddSign) SignedValue = -SignedValue;
  return SignedValue;
}

/// Convenience class to be able to print value ids to raw_ostream's.
/// Kinds of bitcode Ids:
///    a : For abbreviations.
///    b : For basic blocks.
///    c : For local constants.
///    f : For function addresses.
///    g : For global variable addresses.
///    p : For parameter arguments.
///    t : For type values.
///    v : For values generated by instructions.
class BitcodeId {
public:
  BitcodeId(char Kind, uint32_t Index)
      : Kind(Kind), Index(Index), IsGlobal(IsGlobalKind(Kind)) {
  }

  BitcodeId(const BitcodeId &Id)
      : Kind(Id.Kind), Index(Id.Index), IsGlobal(Id.IsGlobal) {}

  void operator=(const BitcodeId &Id) {
    Kind = Id.Kind;
    Index = Id.Index;
    IsGlobal = Id.IsGlobal;
  }

  raw_ostream &Print(raw_ostream &Stream) const {
    return Stream << Prefix() << Kind << Index;
  }

private:
  char Kind;
  uint32_t Index;
  bool IsGlobal;

  // Returns true if (default) assumption for kind implies global.
  static bool IsGlobalKind(char Kind);

  // Returns the bitcode prefix character that communicates if the
  // bitcode Id is lcoal or global.
  char Prefix() const { return IsGlobal ? '@' : '%'; }
};

bool BitcodeId::IsGlobalKind(char Kind) {
  switch (Kind) {
  case 'f':
  case 'g':
  case 't':
    return true;
  case 'b':
  case 'c':
  case 'p':
  case 'v':
    return false;
  default:
    errs() << "Bad bitcode id, can't determine (statically) if global: "
           << Kind << "\n";
    report_fatal_error("Unable to continue");
  }
}

raw_ostream &operator<<(raw_ostream &Stream, const BitcodeId &Id) {
  return Id.Print(Stream);
}

/// The text formatter for PNaClAsm instructions.
class AssemblyTextFormatter : public naclbitc::TextFormatter {
public:
  // Special directive to tokenize type expressions. Used to convert
  // type signatures into a sequence of tokens.
  class TypeDirective : public naclbitc::TextFormatter::Directive {
  public:
    TypeDirective(AssemblyTextFormatter *Formatter)
        : naclbitc::TextFormatter::Directive(Formatter),
          Typ(0),
          FcnId(0),
          AddParams(false) {}

    virtual ~TypeDirective() {}

    /// Calls the corresponding method in AssemblyTextFormatter, with
    /// the locally stored arguments.
    virtual void MyApply(bool Replay) const;

    virtual void MaybeSaveForReplay() const {}

  private:
    // The type to tokenize.
    Type *Typ;
    // Pointer to function id, if not NULL.
    BitcodeId *FcnId;
    // true if parameter id's should be added to function signature.
    bool AddParams;

    friend class AssemblyTextFormatter;

    // Internal routine to allow AssemblyTextFormatter::AllocateTypeDirective
    // to initialize a type directive.
    void Init(Type *NewTyp, BitcodeId *NewFcnId, bool NewAddParams) {
      Typ = NewTyp;
      FcnId = NewFcnId;
      AddParams = NewAddParams;
    }
  };

public:

  /// Creates an assembly text formatter for the given dump stream.
  AssemblyTextFormatter(naclbitc::ObjDumpStream &ObjDump)
      : TextFormatter(ObjDump.Assembly(),
                      std::max(20U, GetAssemblyWidth(ObjDump)),
                      "  "),
        Comma(this, ","),
        Semicolon(this, ";"),
        Space(this),
        OpenParen(this, "("),
        CloseParen(this, ")"),
        OpenAngle(this, "<"),
        CloseAngle(this, ">"),
        OpenCurly(this, "{"),
        CloseCurly(this, "}"),
        Endline(this),
        StartCluster(this),
        FinishCluster(this)
  {
    ContinuationIndent = GetIndent(2);
  }

  ~AssemblyTextFormatter() {
    DeleteContainerPointers(TypeDirectiveFreeList);
  }

  naclbitc::TokenTextDirective Comma;
  naclbitc::TokenTextDirective Semicolon;
  naclbitc::SpaceTextDirective Space;
  naclbitc::OpenTextDirective OpenParen;
  naclbitc::CloseTextDirective CloseParen;
  naclbitc::OpenTextDirective OpenAngle;
  naclbitc::CloseTextDirective CloseAngle;
  naclbitc::OpenTextDirective OpenCurly;
  naclbitc::CloseTextDirective CloseCurly;
  naclbitc::EndlineTextDirective Endline;
  naclbitc::StartClusteringDirective StartCluster;
  naclbitc::FinishClusteringDirective FinishCluster;

  /// Prints the given type as a sequence of tokens.
  TypeDirective &TokenizeType(Type *Typ) {
    return AllocateTypeDirective(Typ, 0, false);
  }

  /// Prints the named function type as a sequence of tokens.
  /// Typ is the type signature of the function, and FunctionName
  /// points to the name of the function.
  TypeDirective &TokenizeFunctionType(FunctionType *Typ,
                                      BitcodeId *FunctionName) {
    return AllocateTypeDirective(Typ, FunctionName, false);
  }

  /// Prints the function signature of the function type. Typ is
  /// the type signature of the function. FunctionName points to the
  /// name of the function. Note: Unlike TokenizeFunctionType, this
  /// method also adds the parameter names to paramter argumements.
  TypeDirective &TokenizeFunctionSignature(FunctionType *Typ,
                                           BitcodeId *FunctionName) {
    return AllocateTypeDirective(Typ, FunctionName, true);
  }

private:
  // Converts the given type to tokens, based on the values passed in
  // by TokenizeType, TokenizeFunctionType, or TokenizeFunctionSignature.
  void TokenizeTypeInternal(Type *Typ, BitcodeId* FcnName, bool AddParams);

  // The free list of type directives.
  std::vector<TypeDirective*> TypeDirectiveFreeList;

  // Allocates an instance of TypeDirective with the following fields.
  TypeDirective &AllocateTypeDirective(Type *Typ, BitcodeId *FcnId,
                                       bool AddParams);

  void FreeTypeDirective(const TypeDirective* Dir) {
    TypeDirectiveFreeList.push_back(const_cast<TypeDirective*>(Dir));
  }

  // Computes how wide the assembly portion of the dump file should be.
  static unsigned GetAssemblyWidth(naclbitc::ObjDumpStream &ObjDump) {
    int Diff = 80 - (ObjDump.GetRecordWidth()+1);
    // Make sure there is enough room to print out assembly.
    return Diff < 20 ? 20 : Diff;
  }

};

void AssemblyTextFormatter::TypeDirective::MyApply(bool Replay) const {
  assert(!Replay && "Shouldn't have been saved for replay");
  AssemblyTextFormatter *AssemblyFormatter =
      reinterpret_cast<AssemblyTextFormatter*>(Formatter);
  AssemblyFormatter->TokenizeTypeInternal(Typ, FcnId, AddParams);
  AssemblyFormatter->FreeTypeDirective(this);
}

AssemblyTextFormatter::TypeDirective &AssemblyTextFormatter::
AllocateTypeDirective(Type *Typ, BitcodeId *FcnId, bool AddParams) {
  TypeDirective *Element = 0;
  if (!TypeDirectiveFreeList.empty()) {
    Element = TypeDirectiveFreeList.back();
    TypeDirectiveFreeList.pop_back();
  } else {
    Element = new TypeDirective(this);
  }
  Element->Init(Typ, FcnId, AddParams);
  return *Element;
}

void AssemblyTextFormatter::TokenizeTypeInternal(
    Type *Typ, BitcodeId* FcnName, bool AddParams) {
  switch (Typ->getTypeID()) {
  case Type::VoidTyID:
    TextStream << "void";
    break;
  case Type::FloatTyID:
    TextStream << "float";
    break;
  case Type::DoubleTyID:
    TextStream << "double";
    break;
  case Type::IntegerTyID:
    TextStream << "i" << Typ->getIntegerBitWidth();
    break;
  case Type::VectorTyID: {
    VectorType *VecType = cast<VectorType>(Typ);
    TextStream << StartCluster << OpenAngle << VecType->getNumElements()
               << Space << "x" << Space
               << TokenizeType(VecType->getElementType())
               << CloseAngle << FinishCluster;
    break;
  }
  case Type::FunctionTyID: {
    FunctionType *FcnType = cast<FunctionType>(Typ);
    unsigned NumParams = FcnType->getFunctionNumParams();
    TextStream << StartCluster
               << TokenizeType(FcnType->getReturnType())
               << Space
               << StartCluster;
    if (NumParams > 0) TextStream << StartCluster;
    if (FcnName) TextStream << *FcnName;
    TextStream << OpenParen << FinishCluster;
    bool HasParamStartCluster = false;
    for (unsigned i = 0, NumParams = FcnType->getFunctionNumParams();
         i < NumParams; ++i) {
      if (i > 0) {
        TextStream << Comma << FinishCluster << Space;
        HasParamStartCluster = false;
      }
      TextStream << StartCluster
                 << TokenizeType(FcnType->getFunctionParamType(i));
      if (AddParams) TextStream << Space << BitcodeId('p', i);
      HasParamStartCluster = true;
    }
    if (FcnType->isFunctionVarArg()) {
      if (HasParamStartCluster) {
        TextStream << Comma << FinishCluster << Space;
      }
      TextStream << StartCluster << "...";
      HasParamStartCluster = true;
    }
    if (HasParamStartCluster) TextStream << FinishCluster;
    TextStream << CloseParen << FinishCluster;
    if (NumParams > 0) TextStream << FinishCluster;
    break;
  }
  default:
    report_fatal_error("Unsupported PNaCl type found");
    break;
  }
}

/// Top-level class to parse bitcode file and transform to
/// corresponding disassembled code.
class NaClDisParser : public NaClBitcodeParser {
  NaClDisParser(const NaClDisParser&) LLVM_DELETED_FUNCTION;
  void operator=(const NaClDisParser&) LLVM_DELETED_FUNCTION;

  // The output stream to generate disassembly into.
  naclbitc::ObjDumpStream ObjDump;
public:
  NaClDisParser(NaClBitcodeHeader &Header,
                const unsigned char *HeaderBuffer,
                NaClBitstreamCursor &Cursor,
                raw_ostream &Stream)
      : NaClBitcodeParser(Cursor),
        ObjDump(Stream, !NoRecords, !NoAssembly),
        AssemblyFormatter(ObjDump),
        Header(Header),
        HeaderBuffer(HeaderBuffer),
        NumFunctions(0),
        NumParams(0),
        NumValuedInsts(0),
        UnknownType(Type::getVoidTy(getGlobalContext())),
        PointerType(Type::getInt32Ty(getGlobalContext())),
        ComparisonType(Type::getInt1Ty(getGlobalContext())),
        NumDefinedFunctions(0) {
  }

  virtual ~NaClDisParser() {}

  // Returns the number of errors that were sent to the ObjDump.
  unsigned GetNumErrors() {
    return ObjDump.GetNumErrors();
  }

  /// Generates an error with the given message.
  virtual bool Error(const std::string &Message) override {
    // Use local error routine so that all errors are treated uniformly.
    ObjDump.Error() << Message << "\n";
    return true;
  }

  /// Flushes out objdump and then exits with fatal error.
  void Fatal() {
    Fatal("");
  }

  /// Flushes out objdump and then exits with fatal error, using
  /// the given message.
  void Fatal(const std::string &Message) {
    ObjDump.Fatal(Message);
  }

  /// Parses the top-level module block.
  virtual bool ParseBlock(unsigned BlockID) override;

  /// Installs the given type to the next available type index.
  void InstallType(Type *Ty) {
    TypeIdType.push_back(Ty);
  }

  /// Returns the type associated with the given type index.
  Type *GetType(uint32_t Index) {
    if (Index >= TypeIdType.size()) {
      BitcodeId Id('t', Index);
      Errors() << "Can't find definition for " << Id << "\n";
      Fatal();
    }
    return TypeIdType[Index];
  }

  /// Returns the number of types (currently) defined in the bitcode
  /// file.
  uint32_t GetNumTypes() const {
    return TypeIdType.size();
  }

  /// Installs the given type to the next available function index.
  void InstallFunctionType(Type *Ty) {
    while (FunctionIdType.size() <= NumFunctions) {
      FunctionIdType.push_back(UnknownType);
    }
    FunctionIdType[NumFunctions++] = Ty;
  }

  //// Returns the type associated with the given function index.
  Type *GetFunctionType(uint32_t Index) {
    if (Index >= FunctionIdType.size()) {
      BitcodeId Id('f', Index);
      Errors() << "Can't find definition for " << Id << "\n";
      Fatal();
    }
    return FunctionIdType[Index];
  }

  /// Returns the number of functions (currently) defined/declared in
  /// the bitcode file.
  uint32_t GetNumFunctions() const {
    return NumFunctions;
  }

  /// Installs that the given function index as having a function body
  /// (i.e. the function address uses the "define" keyword instead of
  /// the "declare" keyword).
  void InstallDefinedFunction(uint32_t Index) {
    DefinedFunctions.push_back(Index);
  }

  /// Returns the index associated with the next function block.
  uint32_t GetNextDefinedFunctionIndex() const {
    assert(NumDefinedFunctions < DefinedFunctions.size());
    return DefinedFunctions[NumDefinedFunctions];
  }

  /// Increments the number of (currently) defined functions in the
  /// bitcode file by one.
  void IncNumDefinedFunctions() {
    ++NumDefinedFunctions;
  }

  /// Installs the given type to the next available parameter index.
  void InstallParamType(Type *Ty) {
    while (ParamIdType.size() <= NumParams) {
      ParamIdType.push_back(UnknownType);
    }
    ParamIdType[NumParams++] = Ty;
  }

  /// Returns the type associated with the given parameter index.
  Type *GetParamType(uint32_t Index) {
    if (Index >= ParamIdType.size()) {
      BitcodeId Id('p', Index);
      Errors() << "Can't find defintion for " << Id << "\n";
      Fatal();
    }
    return ParamIdType[Index];
  }

  /// Returns the number of parameters (currently) defined in the
  /// enclosing defined function.
  uint32_t GetNumParams() const {
    return NumParams;
  }

  /// Resets index counters local to a defined function.
  void ResetLocalCounters() {
    ParamIdType.clear();
    NumParams = 0;
    // TODO(kschimpf) Add missing constant and instruction counters.
    InstIdType.clear();
    NumValuedInsts = 0;
  }

  /// Returns the bitcode id associated with the absolute value index
  BitcodeId GetBitcodeId(uint32_t Index);

  /// Returns the type associated with the given absolute value index.
  /// If UnderlyingType is false, function indices always return a
  /// pointer type. Otherwise, function indices returns the declared
  /// type of the function index.
  Type *GetValueType(uint32_t Index, bool UnderlyingType = false);

  /// Returns a type to use when the type is unknown.
  Type *GetUnknownType() const {
    return UnknownType;
  }

  /// Returns the type used to represent a pointer.
  Type *GetPointerType() const {
    return PointerType;
  }

  /// Returns the type used to represent comparison results.
  Type *GetComparisonType() const {
    return ComparisonType;
  }

  /// Returns the void type.
  Type *GetVoidType() const {
    return Type::getVoidTy(getGlobalContext());
  }

  /// Returns the float (32-bit) type.
  Type *GetFloatType() const {
    return Type::getFloatTy(getGlobalContext());
  }

  /// Returns the double (64-bit) type.
  Type *GetDoubleType() const {
    return Type::getDoubleTy(getGlobalContext());
  }

  /// Returns an integer type of N bits.
  Type *GetIntegerType(unsigned N) const {
    return Type::getIntNTy(getGlobalContext(), N);
  }

  // ******************************************************
  // The following return the corresponding methods/fields
  // from the the assembly formatter/objdumper.
  // ******************************************************

  naclbitc::TokenTextDirective &Semicolon() {
    return AssemblyFormatter.Semicolon;
  }

  naclbitc::SpaceTextDirective &Space() {
    return AssemblyFormatter.Space;
  }

  naclbitc::TokenTextDirective &Comma() {
    return AssemblyFormatter.Comma;
  }

  naclbitc::OpenTextDirective &OpenParen() {
    return AssemblyFormatter.OpenParen;
  }

  naclbitc::CloseTextDirective &CloseParen() {
    return AssemblyFormatter.CloseParen;
  }

  naclbitc::OpenTextDirective &OpenCurly() {
    return AssemblyFormatter.OpenCurly;
  }

  naclbitc::CloseTextDirective &CloseCurly() {
    return AssemblyFormatter.CloseCurly;
  }

  naclbitc::EndlineTextDirective &Endline() {
    return AssemblyFormatter.Endline;
  }

  naclbitc::StartClusteringDirective &StartCluster() {
    return AssemblyFormatter.StartCluster;
  }

  naclbitc::FinishClusteringDirective &FinishCluster() {
    return AssemblyFormatter.FinishCluster;
  }

  raw_ostream &Tokens() {
    return AssemblyFormatter.Tokens();
  }

  raw_ostream &Errors() {
    return ObjDump.Error();
  }

  const std::string &GetAssemblyIndent() const {
    return AssemblyFormatter.GetIndent();
  }

  unsigned GetAssemblyNumTabs() const {
    return AssemblyFormatter.GetNumTabs();
  }

  void IncAssemblyIndent() {
    AssemblyFormatter.Inc();
  }

  void DecAssemblyIndent() {
    AssemblyFormatter.Dec();
  }

  void IncRecordIndent() {
    ObjDump.IncRecordIndent();
  }

  void DecRecordIndent() {
    ObjDump.DecRecordIndent();
  }

  void ObjDumpFlush() {
    ObjDump.Flush();
  }

  void ObjDumpSetRecordBitAddress(uint64_t Bit) {
    ObjDump.SetRecordBitAddress(Bit);
  }

  void ObjDumpWrite(uint64_t Bit, const NaClBitcodeRecordData &Record) {
    ObjDump.Write(Bit, Record);
  }

  AssemblyTextFormatter::TypeDirective &
  TokenizeType(Type *Typ) {
    return AssemblyFormatter.TokenizeType(Typ);
  }

  AssemblyTextFormatter::TypeDirective &
  TokenizeFunctionType(FunctionType *Type, BitcodeId *FcnId) {
    return AssemblyFormatter.TokenizeFunctionType(Type, FcnId);
  }

  AssemblyTextFormatter::TypeDirective &
  TokenizeFunctionSignature(FunctionType *Typ, BitcodeId *FcnId) {
    return AssemblyFormatter.TokenizeFunctionSignature(Typ, FcnId);
  }

private:
  // The formatter to use to format assembly code.
  AssemblyTextFormatter AssemblyFormatter;
  // The header appearing before the beginning of the input stream.
  NaClBitcodeHeader &Header;
  // Pointer to the buffer containing the header.
  const unsigned char *HeaderBuffer;
  // The list of known types (index i defines the type associated with
  // type index i).
  std::vector<Type*>TypeIdType;
  // The number of type indices currently defined.
  uint32_t NumTypes;
  // The list of known function signatures (index i defines the type
  // signature associated with function index i).
  std::vector<Type*>FunctionIdType;
  // The number of function indices currently defined.
  uint32_t NumFunctions;
  // The list of known parameter types (index i defines the type
  // associated with parameter index i).
  std::vector<Type*>ParamIdType;
  // The number of parameter indices currently defined.
  uint32_t NumParams;
  // The list of known instruction types (index i defines the type
  // associated with valued instruction index i).
  std::vector<Type*> InstIdType;
  // The number of valued instructions currently defined.
  uint32_t NumValuedInsts;
  // Models an unknown type.
  Type *UnknownType;
  // Models the pointer type.
  Type *PointerType;
  // Models a result of a comparison.
  Type *ComparisonType;
  // Keeps list of function indicies (in the order found in the bitcode)
  // that correspond to defined functions.
  std::vector<uint32_t> DefinedFunctions;
  // The number of function indices currently known to be defined.
  uint32_t NumDefinedFunctions;
};

BitcodeId NaClDisParser::GetBitcodeId(uint32_t Index) {
  if (Index < NumFunctions) {
    return BitcodeId('f', Index);
  }
  Index -= NumFunctions;
  if (Index < NumParams) {
    return BitcodeId('p', Index);
  }
  Index -= NumParams;
  // TODO(kschimpf): Add global addresses.
  // TODO(kschimpf): Add function-level constants.
  // TODO(kschimpf): Add instruction values.
  return BitcodeId('v', Index);
}

Type *NaClDisParser::GetValueType(uint32_t Index, bool UnderlyingType) {
  if (Index < NumFunctions)
    return UnderlyingType ? GetFunctionType(Index) : PointerType;
  Index -= NumFunctions;
  // TODO(kschimpf): Add adjustment for global addresses.
  if (Index < NumParams)
    return GetParamType(Index);
  // TODO(kschimpf): Add adjustment for function-level constants
  // and instructions.
  Errors() << "Can't find type for (absolute) index: " << Index;
}

// Base class of all block parsers for the bitcode file. Handles
// common actions needed by derived blocks.
//
// Note: This class also handles blocks with unknown block ID's.
class NaClDisBlockParser : public NaClBitcodeParser {
protected:
  /// Constructor for the top-level block parser.
  NaClDisBlockParser(unsigned BlockID, NaClDisParser *Context)
      : NaClBitcodeParser(BlockID, Context),
        Context(Context) {
  }

  /// Constructor for nested block parsers.
  NaClDisBlockParser(unsigned BlockID, NaClDisBlockParser *EnclosingParser)
      : NaClBitcodeParser(BlockID, EnclosingParser),
        Context(EnclosingParser->Context) {
  }

public:

  virtual ~NaClDisBlockParser() {}

  virtual bool ParseBlock(unsigned BlockID) override;

  virtual void EnterBlock(unsigned NumWords) override;

  virtual void ExitBlock() override;

  virtual void ProcessRecord() override;

protected:
  // Prints the block header instruction for the block. Called by EnterBlock.
  virtual void PrintBlockHeader();

  // Dumps the corresponding record for a block enter.
  void DumpEnterBlockRecord();

  // *****************************************************************
  // The following are dispatching methods that call the corresponding
  // method on the Context (i.e. NaClDisParser).
  // *****************************************************************

  /// Returns a directive to tokenize the given type.
  AssemblyTextFormatter::TypeDirective &TokenizeType(Type *Type) {
    return Context->TokenizeType(Type);
  }

  /// Returns a directive to tokenize the given function type,
  /// using the given function id.
  AssemblyTextFormatter::TypeDirective
  &TokenizeFunctionType(FunctionType *Type, BitcodeId *FcnId) {
    return Context->TokenizeFunctionType(Type, FcnId);
  }

  /// Returns a directive to tokenize the function signature, given the
  /// type of the function signature, and the given function id.
  AssemblyTextFormatter::TypeDirective
  &TokenizeFunctionSignature(FunctionType *Typ, BitcodeId *FcnId) {
    return Context->TokenizeFunctionSignature(Typ, FcnId);
  }

  naclbitc::TokenTextDirective &Semicolon() {
    return Context->Semicolon();
  }

  naclbitc::SpaceTextDirective &Space() {
    return Context->Space();
  }

  naclbitc::OpenTextDirective &OpenParen() {
    return Context->OpenParen();
  }


  naclbitc::CloseTextDirective &CloseParen() {
    return Context->CloseParen();
  }

  naclbitc::OpenTextDirective &OpenCurly() {
    return Context->OpenCurly();
  }

  naclbitc::CloseTextDirective &CloseCurly() {
    return Context->CloseCurly();
  }

  naclbitc::EndlineTextDirective &Endline() {
    return Context->Endline();
  }

  naclbitc::StartClusteringDirective &StartCluster() {
    return Context->StartCluster();
  }

  naclbitc::FinishClusteringDirective &FinishCluster() {
    return Context->FinishCluster();
  }

  raw_ostream &Tokens() {
    return Context->Tokens();
  }

  raw_ostream &Errors() {
    return Context->Errors();
  }

  void Fatal() {
    return Context->Fatal();
  }

  void Fatal(const std::string &Message) {
    return Context->Fatal(Message);
  }

  const std::string &GetAssemblyIndent() const {
    return Context->GetAssemblyIndent();
  }

  unsigned GetAssemblyNumTabs() const {
    return Context->GetAssemblyNumTabs();
  }

  void IncAssemblyIndent() {
    Context->IncAssemblyIndent();
  }

  void DecAssemblyIndent() {
    Context->DecAssemblyIndent();
  }

  void IncRecordIndent() {
    Context->IncRecordIndent();
  }

  void DecRecordIndent() {
    Context->DecRecordIndent();
  }

  void ObjDumpFlush() {
    Context->ObjDumpFlush();
  }

  void ObjDumpWrite(uint64_t Bit, const NaClBitcodeRecordData &Record) {
    Context->ObjDumpWrite(Bit, Record);
  }

  void ObjDumpSetRecordBitAddress(uint64_t Bit) {
    Context->ObjDumpSetRecordBitAddress(Bit);
  }

  void InstallType(Type *Ty) {
    Context->InstallType(Ty);
  }

  Type *GetType(uint32_t Index) {
    return Context->GetType(Index);
  }

  uint32_t GetNumTypes() const {
    return Context->GetNumTypes();
  }

  Type *GetFunctionType(uint32_t Index) {
    return Context->GetFunctionType(Index);
  }

  uint32_t GetNumFunctions() const {
    return Context->GetNumFunctions();
  }

  void InstallFunctionType(Type *Ty) {
    return Context->InstallFunctionType(Ty);
  }

  void InstallDefinedFunction(uint32_t Index) {
    Context->InstallDefinedFunction(Index);
  }

  uint32_t GetNextDefinedFunctionIndex() const {
    return Context->GetNextDefinedFunctionIndex();
  }

  BitcodeId GetBitcodeId(uint32_t Id) {
    return Context->GetBitcodeId(Id);
  }

  void InstallParamType(Type *Ty) {
    Context->InstallParamType(Ty);
  }

  uint32_t GetNumParams() const {
    return Context->GetNumParams();
  }

  Type *GetValueType(uint32_t Id, bool UnderlyingType = false) {
    return Context->GetValueType(Id, UnderlyingType);
  }

  Type *GetUnknownType() const {
    return Context->GetUnknownType();
  }

  Type *GetPointerType() const {
    return Context->GetPointerType();
  }

  Type *GetComparisonType() const {
    return Context->GetComparisonType();
  }

  Type *GetVoidType() const {
    return Context->GetVoidType();
  }

  Type *GetFloatType() const {
    return Context->GetFloatType();
  }

  Type *GetDoubleType() const {
    return Context->GetDoubleType();
  }

  Type *GetIntegerType(unsigned Size) const {
    return Context->GetIntegerType(Size);
  }

protected:
  // The context parser that contains decoding state.
  NaClDisParser *Context;
};

bool NaClDisBlockParser::ParseBlock(unsigned BlockId) {
  // Only called if we don't know the details about the block.
  ObjDumpSetRecordBitAddress(GetBlock().GetStartBit());
  Errors() << "Don't know how to parse block " << BlockId
           << ", when in block " << GetBlockID() << "\n";
  NaClDisBlockParser Parser(BlockId, this);
  return Parser.ParseThisBlock();
}

void NaClDisBlockParser::PrintBlockHeader() {
  Errors() << "Unknown block id found: " << GetBlockID() << "\n";
  Tokens() << "unknown" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = "
           << GetBlockID() << Endline();
}

void NaClDisBlockParser::EnterBlock(unsigned NumWords) {
  PrintBlockHeader();
  DumpEnterBlockRecord();
  IncRecordIndent();
  IncAssemblyIndent();
}

void NaClDisBlockParser::ExitBlock() {
  DecAssemblyIndent();
  DecRecordIndent();
  Tokens() << CloseCurly() << Endline();
  NaClBitcodeRecordData Exit;
  Exit.Code = naclbitc::BLK_CODE_EXIT;
  ObjDumpWrite(Record.GetStartBit(), Exit);
}

void NaClDisBlockParser::DumpEnterBlockRecord() {
  // TODO(kschimpf): Better integrate this with the bitstream reader
  // (which currently doesn't build any records).
  NaClBitcodeRecordData Enter;
  Enter.Code = naclbitc::BLK_CODE_ENTER;
  Enter.Values.push_back(GetBlockID());
  Enter.Values.push_back(Record.GetCursor().getAbbrevIDWidth());
  ObjDumpWrite(GetBlock().GetStartBit(), Enter);
}

void NaClDisBlockParser::ProcessRecord() {
  // Note: Only called if block is not understood. Hence, we
  // only report the records.
  ObjDumpWrite(Record.GetStartBit(), Record.GetRecordData());
}

/// Parses and disassembles the blockinfo block.
/// TODO(kschimpf): Make this understand record structure
/// of this block. Currently can't be done because it is
/// all handled in the bitstream reader.
class NaClDisBlockInfoParser : public NaClDisBlockParser {
public:
  NaClDisBlockInfoParser(unsigned BlockID,
                         NaClDisBlockParser *EnclosingParser)
      : NaClDisBlockParser(BlockID, EnclosingParser) {
  }

  virtual void ProcessBlockInfo() override {
    EnterBlock(0);
  }

  virtual void PrintBlockHeader() override;

  virtual ~NaClDisBlockInfoParser() {}
};

void NaClDisBlockInfoParser::PrintBlockHeader() {
  Tokens() << "abbreviations" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = "
           << GetBlockID() << Endline();
}

/// Parses and disassembles the types block.
class NaClDisTypesParser : public NaClDisBlockParser {
public:
  NaClDisTypesParser(unsigned BlockID,
                     NaClDisBlockParser *EnclosingParser)
      : NaClDisBlockParser(BlockID, EnclosingParser),
        ExpectedNumTypes(0),
        IsFirstRecord(true)
  {
  }

  virtual ~NaClDisTypesParser();

private:
  virtual void PrintBlockHeader() override;

  virtual void ProcessRecord() override;

  /// Returns the value id for the next type to be defined.
  BitcodeId NextTypeId() {
    return BitcodeId('t', GetNumTypes());
  }

  uint32_t ExpectedNumTypes;
  bool IsFirstRecord;
};

NaClDisTypesParser::~NaClDisTypesParser() {
  if (GetNumTypes() != ExpectedNumTypes) {
    Errors() << "Expected " << ExpectedNumTypes << " types but found: "
             << GetNumTypes() << "\n";
  }
}

void NaClDisTypesParser::PrintBlockHeader() {
  Tokens() << "types" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

void NaClDisTypesParser::ProcessRecord() {
  ObjDumpSetRecordBitAddress(Record.GetStartBit());
  const NaClBitcodeRecord::RecordVector &Values = Record.GetValues();
  switch (Record.GetCode()) {
  case naclbitc::TYPE_CODE_NUMENTRY: {
    // NUMENTRY: [numentries]
    uint64_t Size = 0;
    if (Values.size() == 1) {
      Size = Values[0];
    } else {
      Errors() << "Count record should have 1 argument. Found: "
               << Values.size() << "\n";
    }
    if (!IsFirstRecord) {
      Errors() << "Count record not first record of types block\n";
    }
    Tokens() << "count" << Space() << Size << Semicolon() << Endline();
    ExpectedNumTypes = Size;
    break;
  }
  case naclbitc::TYPE_CODE_VOID: {
    // VOID
    if (!Values.empty())
      Errors() << "Void record shouldn't have arguments. Found: "
               << Values.size() << "\n";
    Type *VoidType = GetVoidType();
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << TokenizeType(VoidType) << Semicolon() << Endline();
    InstallType(VoidType);
    break;
  }
  case naclbitc::TYPE_CODE_FLOAT: {
    // FLOAT
    if (!Values.empty())
      Errors() << "Float record shoudn't have arguments. Found: "
               << Values.size() << "\n";
    Type *FloatType = GetFloatType();
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << TokenizeType(FloatType) << Semicolon() << Endline();
    InstallType(FloatType);
    break;
  }
  case naclbitc::TYPE_CODE_DOUBLE: {
    // DOUBLE
    if (!Values.empty())
      Errors() << "Double record shound't have arguments. Found: "
               << Values.size() << "\n";
    Type *DoubleType = GetDoubleType();
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << TokenizeType(DoubleType) << Semicolon() << Endline();
    InstallType(DoubleType);
    break;
  }
  case naclbitc::TYPE_CODE_INTEGER: {
    // INTEGER: [width]
    uint64_t Size;
    if (Values.size() == 1) {
      Size = Values[0];
    } else {
      Errors() << "Integer record should have one argument. Found: "
               << Values.size() << "\n";
      Size = 32;
    }
    switch (Size) {
      case 1:
      case 8:
      case 16:
      case 32:
      case 64: {
          break;
        }
      default:
        Errors() << "Integer record contains bad integer size: "
                 << Size << "\n";
        Size = 32;
        break;
    }
    Type *IntType = GetIntegerType(Size);
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << TokenizeType(IntType) << Semicolon() << Endline();
    InstallType(IntType);
    break;
  }
  case naclbitc::TYPE_CODE_VECTOR: {
    // VECTOR: [numelts, eltty]
    if (Values.size() != 2) {
      Errors() << "Vector record should contain two arguments. Found: "
               << Values.size() << "\n";
      InstallType(GetUnknownType());
      break;
    }
    Type *VecType = VectorType::get(GetType(Values[1]), Values[0]);
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << TokenizeType(VecType) << Semicolon() << Endline();
    InstallType(VecType);
    break;
  }
  case naclbitc::TYPE_CODE_FUNCTION: {
    // FUNCTION: [vararg, retty, paramty x N]
    if (Values.size() < 2) {
      Errors()
          << "Function record should contain at least 2 arguments. Found: "
          << Values.size() << "\n";
      InstallType(GetUnknownType());
      break;
    }
    if (Values[0]) {
      Errors() << "Functions with variable length arguments is not supported\n";
    }
    Type *ReturnType = GetType(Values[1]);
    SmallVector<Type*, 8> Signature;
    for (size_t i = 2; i < Values.size(); ++i) {
      if (Type *Ty = GetType(Values[i])) {
        Signature.push_back(Ty);
      } else {
        Errors() << "Invalid parameter type: record element " << i << "\n";
      }
    }
    Type *FcnType =  FunctionType::get(ReturnType, Signature, Values[0]);
    Tokens() << NextTypeId() << Space() << "=" << Space()
             << StartCluster() << TokenizeType(FcnType)
             << Semicolon() << FinishCluster() << Endline();
    InstallType(FcnType);
    break;
  }
  default:
    Errors() << "Unknown record in types block.\n";
    break;
  }
  ObjDumpWrite(Record.GetStartBit(), Record.GetRecordData());
  IsFirstRecord = false;
}

/// Parses and disassembles the globalvars block.
/// TODO(kschimpf): Process records of this class.
class NaClDisGlobalsParser : public NaClDisBlockParser {
public:
  NaClDisGlobalsParser(unsigned BlockID,
                       NaClDisBlockParser *EnclosingParser)
      : NaClDisBlockParser(BlockID, EnclosingParser) {}

  virtual ~NaClDisGlobalsParser() {}

  virtual void PrintBlockHeader() override;
};

void NaClDisGlobalsParser::PrintBlockHeader() {
  Tokens() << "globals" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

/// Parsers and disassembles a valuesymtab block.
/// TODO(kschimpf): Process records of this class.
class NaClDisValueSymtabParser : public NaClDisBlockParser {
public:
  NaClDisValueSymtabParser(unsigned BlockID,
                           NaClDisBlockParser *EnclosingParser)
      : NaClDisBlockParser(BlockID, EnclosingParser) {
  }

  virtual ~NaClDisValueSymtabParser() {}

  virtual void PrintBlockHeader() override;
};

void NaClDisValueSymtabParser::PrintBlockHeader() {
  Tokens() << "valuesymtab" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

/// Parses and disassembles a constants block.
/// TODO(kschimpf): Process records of this class.
class NaClDisConstantsParser : public NaClDisBlockParser {
public:
  NaClDisConstantsParser(unsigned BlockID,
                         NaClDisBlockParser *EnclosingParser)
      : NaClDisBlockParser(BlockID, EnclosingParser) {}

  virtual ~NaClDisConstantsParser() {}

  virtual void PrintBlockHeader() override;
};

void NaClDisConstantsParser::PrintBlockHeader() {
  Tokens() << "constants" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

/// Parses and disassembles function blocks.
/// TODO(kschimpf): Process records of this class.
class NaClDisFunctionParser : public NaClDisBlockParser {
public:
  NaClDisFunctionParser(unsigned BlockID,
                        NaClDisBlockParser *EnclosingParser);

  virtual ~NaClDisFunctionParser() {
    Context->ResetLocalCounters();
  }

  virtual void PrintBlockHeader() override;

  virtual bool ParseBlock(unsigned BlockID) override;
private:
  // The function index of the function being defined.
  uint32_t FcnId;
};

NaClDisFunctionParser::NaClDisFunctionParser(
    unsigned BlockID,
    NaClDisBlockParser *EnclosingParser)
    : NaClDisBlockParser(BlockID, EnclosingParser) {
  FcnId = Context->GetNextDefinedFunctionIndex();
  Context->IncNumDefinedFunctions();

  // Now install parameters.
  Type *Ty = GetFunctionType(FcnId);
  assert(Ty->isFunctionTy());
  for (size_t Index = 0; Index < Ty->getFunctionNumParams(); ++Index) {
    InstallParamType(Ty->getFunctionParamType(Index));
  }
}

void NaClDisFunctionParser::PrintBlockHeader() {
  Type *FcnTy = GetFunctionType(FcnId);
  Tokens() << "function" << Space();
  BitcodeId FunctionId('f', FcnId);
  if (FunctionType *FunctionTy = dyn_cast<FunctionType>(FcnTy)) {
    Tokens() << TokenizeFunctionSignature(FunctionTy, &FunctionId);
  } else {
    Tokens() << "???" << Space() << FunctionId
             << OpenParen() << "???" << CloseParen();
    Errors()
        << "Can't find function definition (from module block) for: "
        << FunctionId << "\n";
  }
  Tokens() << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

bool NaClDisFunctionParser::ParseBlock(unsigned BlockID) {
  ObjDumpSetRecordBitAddress(GetBlock().GetStartBit());
  switch (BlockID) {
  case naclbitc::CONSTANTS_BLOCK_ID: {
    NaClDisConstantsParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  case naclbitc::VALUE_SYMTAB_BLOCK_ID: {
    if (!PNaClAllowLocalSymbolTables) break;
    NaClDisValueSymtabParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  default:
    break;
  }
  return NaClDisBlockParser::ParseBlock(BlockID);
}

/// Parses and disassembles the module block.
class NaClDisModuleParser : public NaClDisBlockParser {
public:
  NaClDisModuleParser(unsigned BlockID, NaClDisParser *Context)
      : NaClDisBlockParser(BlockID, Context) {
  }

  virtual ~NaClDisModuleParser() {}

  virtual bool ParseBlock(unsigned BlockID) override;

  virtual void PrintBlockHeader() override;

  virtual void ProcessRecord() override;
};

bool NaClDisModuleParser::ParseBlock(unsigned BlockID) {
  ObjDumpSetRecordBitAddress(GetBlock().GetStartBit());
  switch (BlockID) {
  case naclbitc::BLOCKINFO_BLOCK_ID: {
    NaClDisBlockInfoParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  case naclbitc::TYPE_BLOCK_ID_NEW: {
    NaClDisTypesParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  case naclbitc::GLOBALVAR_BLOCK_ID: {
    NaClDisGlobalsParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  case naclbitc::VALUE_SYMTAB_BLOCK_ID: {
    NaClDisValueSymtabParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  case naclbitc::FUNCTION_BLOCK_ID: {
    NaClDisFunctionParser Parser(BlockID, this);
    return Parser.ParseThisBlock();
  }
  default:
    return NaClDisBlockParser::ParseBlock(BlockID);
  }
}

void NaClDisModuleParser::PrintBlockHeader() {
  Tokens() << "module" << Space() << OpenCurly()
           << Space() << Space() << "// BlockID = " << GetBlockID()
           << Endline();
}

void NaClDisModuleParser::ProcessRecord() {
  ObjDumpSetRecordBitAddress(Record.GetStartBit());
  const NaClBitcodeRecord::RecordVector &Values = Record.GetValues();
  switch (Record.GetCode()) {
  case naclbitc::MODULE_CODE_VERSION:
    // [version#]
    if (Values.size() != 1) {
      Errors() << "Version record should have one argument. Found: "
               << Values.size() << "\n";
      break;
    }
    Tokens() << "version" << Space() << Values[0] << Semicolon() << Endline();
    break;
  case naclbitc::MODULE_CODE_FUNCTION: {
    // [type, callingconv, isproto, linkage]
    if (Values.size() != 4) {
      Errors() << "Function record should have 4 arguments. Found: "
               << Values.size() << "\n";
      break;
    }
    bool IsProto = (Values[2] != 0);
    Tokens() << StartCluster() << (IsProto ? "declare" : "define") << Space();
    switch (Values[3]) {
    case 0:
      Tokens() << "external";
      break;
    case 3:
      Tokens() << "internal";
      break;
    default:
      Errors() << "Unknown linkage value: " << Values[3] << "\n";
      break;
    }
    if (Values[1] != naclbitc::C_CallingConv)
      Errors() << "Unknown calling convention value: " << Values[1] << "\n";
    Tokens() << FinishCluster() << Space() << StartCluster();
    uint32_t FcnId = GetNumFunctions();
    Type *FcnType = GetType(Values[0]);
    BitcodeId FcnName('f', FcnId);
    if (FunctionType *FunctionTy = dyn_cast<FunctionType>(FcnType)) {
      Tokens() << TokenizeFunctionType(FunctionTy, &FcnName);
    } else {
      BitcodeId FcnTypeId('t', Values[0]);
      Errors() << "Not function type: " << FcnTypeId << " = "
               << *FcnType << "\n";
      Tokens() << "???";
      SmallVector<Type*, 1> Signature;
      FcnType = FunctionType::get(GetVoidType(), Signature, 0);
    }
    Tokens() << Semicolon() << FinishCluster() << Endline();
    InstallFunctionType(FcnType);
    if (!IsProto) InstallDefinedFunction(FcnId);
    break;
  }
  default:
    Errors() << "Unknown Record found in module block\n";
    break;
  }
  ObjDumpWrite(Record.GetStartBit(), Record.GetRecordData());
}

bool NaClDisParser::ParseBlock(unsigned BlockID) {
  // Before parsing top-level module block. Describe header.
  NaClBitcodeRecordData Record;
  size_t HeaderSize = Header.getHeaderSize();
  Record.Code = naclbitc::BLK_CODE_HEADER;
  for (size_t i = 0; i < HeaderSize; ++i) {
    Record.Values.push_back(HeaderBuffer[i]);
  }
  if (ObjDump.GetDumpRecords() && ObjDump.GetDumpAssembly()) {
    if (HeaderSize >= 4) {
      const NaClRecordVector &Values = Record.Values;
      Tokens() << "Magic" << Space() << "Number" << ":"
               << Space() << StartCluster() << StartCluster() << "'"
               << (char) Values[0] << (char) Values[1]
               << (char) Values[2] << (char) Values[3]
               << "'" << FinishCluster() << Space()
               << StartCluster() << OpenParen()
               << Values[0] << Comma() << Space()
               << Values[1] << Comma() << Space()
               << Values[2] << Comma() << Space()
               << Values[3] << CloseParen() << FinishCluster()
               << FinishCluster() << Endline();
    }
    // Show interpretation of header as assembly.
    for (size_t i = 0; i < Header.NumberFields(); ++i) {
      Tokens() << Header.GetField(i)->Contents() << Endline();
    }
  }
  ObjDump.Write(0, Record);
  ObjDump.SetStartOffset(HeaderSize * 8);

  // Now parse a module block.
  NaClDisModuleParser Parser(BlockID, this);
  return Parser.ParseThisBlock();
}

// Reads and disassembles the bitcode file. Returns false
// if successful, true otherwise.
static bool DisassembleBitcode() {
  // Open the bitcode file and put into a buffer.
  std::unique_ptr<MemoryBuffer> MemBuf;
  if (std::error_code ec =
      MemoryBuffer::getFileOrSTDIN(InputFilename.c_str(), MemBuf)) {
    errs() << "Error reading '" << InputFilename << "': "
           << ec.message() << "\n";
    return true;
  }

  if (MemBuf->getBufferSize() % 4 != 0) {
    errs() << "Bitcode stream should be a multiple of 4 bytes in length.\n";
    return true;
  }

  const unsigned char *BufPtr = (const unsigned char *)MemBuf->getBufferStart();
  const unsigned char *EndBufPtr = BufPtr+MemBuf->getBufferSize();
  const unsigned char *HeaderPtr = BufPtr;

  // Read header and verify it is good.
  NaClBitcodeHeader Header;
  if (Header.Read(BufPtr, EndBufPtr) || !Header.IsSupported()) {
    errs() << "Invalid PNaCl bitcode header.\n";
    return true;
  }

  // Create a bitstream reader to read the bitcode file.
  NaClBitstreamReader InputStreamFile(BufPtr, EndBufPtr);
  NaClBitstreamCursor InputStream(InputStreamFile);

  // Create a stream to output the bitcode text to.
  std::string ErrorInfo;
  raw_fd_ostream Output(OutputFilename.c_str(), ErrorInfo, sys::fs::F_None);
  if (!ErrorInfo.empty()) {
    errs() << ErrorInfo << '\n';
    return true;
  }

  // Parse the the bitcode file.
  NaClDisParser Parser(Header, HeaderPtr, InputStream, Output);
  while (!InputStream.AtEndOfStream()) {
    if (Parser.Parse()) return true;
  }
  return Parser.GetNumErrors() > 0;
}

}

int main(int argc, char **argv) {
  // Print a stack trace if we signal out.
  sys::PrintStackTraceOnErrorSignal();
  PrettyStackTraceProgram X(argc, argv);
  llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.
  cl::ParseCommandLineOptions(argc, argv, "pnacl-bccompress file analyzer\n");

  if (DisassembleBitcode()) return 1;
  return 0;
}
